---
title: "MCMC Homework"
author: "Vuk Đuranović"
date: "5/30/2022"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

In this homework we will generate samples from four different distributions (Scenarios), using three different algorithms: Metropolis-Hastings, Hamiltonian Monte-Carlo (HMC for short) and Rejection sampling. For each scenario we will run usual MCMC diagnostic plots and we will display results side by side for each algorithm for easier comparison 

## Sceniario: Bivariate standard normal

```{r, echo=FALSE}
traceplot <- function(x) {
  tp <- vector()
  print(paste('Length is:', length(x)))
  for (i in 1:length(x)) {
    tp <- c(tp, mean(x[1:i]))
  }
  tp
}
```

```{r, echo=FALSE}
library(mvtnorm)
library(ggplot2)

metropolis_hastings <- function(p, k, start_state, m, cov_matrix) {
  # p is the target distribution function
  # k is the proposal distribution function
  # start_state is starting state
  # m is the number of samples we want to draw
  x <- start_state
  ndims <- nrow(cov_matrix)
  samples <- x
  
  for (i in 1:(m-1)) {
    # k = rmvnorm
    # delta <- k(1, rep(0, nrow(cov_matrix)), cov_matrix)
    x_new <- k(1, x, cov_matrix)
    alpha <- min(1, p(x_new) / p(x))
    if(is.nan(alpha)) {
      alpha <- 0
    }
    u <- runif(1)
    if(u > alpha) {
      x_new <- x
    } 
    samples <- rbind(samples, x_new)
    x <- x_new
    
  }
  samples
  
}

cov_matrix_prop <- matrix(c(1, 0, 0, 1), ncol=2, nrow=2)
```

```{r, echo=FALSE}
# HMC
source("HMC.r")
source("Multiplot.r")
library(ggplot2)
library(numDeriv)
library(coda)
library(grid)

minus_log_bivar_st_norm <- function(x) {
  log(2 * pi) + 0.5 * sum(x * t(x))
}

grad_minus_log_bivar_st_norm <- function(x) {
  x
}

# example 2 - banana-shaped distribution
B <- 0.05


## HMC
L = 10
epsilon = 0.25
current_q = c(0,0)
m = 1000

samples <- NULL
for (i in 1:m) {
  print(i)
  res = HMC(minus_log_bivar_st_norm, grad_minus_log_bivar_st_norm, epsilon, L, current_q)
  samples = rbind(samples, data.frame(Q1 = res$next_q[1], Q2 = res$next_q[2]))
  current_q = res$next_q
}

hmc_make_samples <- function(mlogU, grad_mlogU, epsilon, L, current_q, m) {
  samples <- NULL
  for (i in 1:m) {
    print(i)
    res = HMC(minus_log_bivar_st_norm, grad_minus_log_bivar_st_norm, epsilon, L, current_q)
    samples = rbind(samples, data.frame(Q1 = res$next_q[1], Q2 = res$next_q[2]))
    current_q = res$next_q
  }
  samples
}

```

```{r, echo=FALSE}
# rejection sampling

rejection_sampling <- function(m, target_dens_func, renvelope, denvelope, c) {
  # m is the number of samples that we want
  # target_dens_func needless to say, the pdf of target distribution
  # renvelope is a function for generating samples from envelope distribution
  samples <- vector()
  for (i in 1:m) {
    # print(i)
    # print('*******************')
    cand_valid <- F
    while(cand_valid == F) {
      x_cand <- renvelope(1)
      u <- runif(1, 0, denvelope(x_cand, c))
      # print(x_cand)
      # print(target_dens_func(x_cand))
      # print(u <= target_dens_func(x_cand))
      # print('-----------------------')
      cand_valid <- u <= target_dens_func(x_cand)
      if (cand_valid) {
        samples <- rbind(samples, x_cand)
      }
    }
  }
  
  samples
}

renvelope_for_bivariate <- function(n) {
  x <- rbeta(n, 2, 2) * 8 - 4
  y <- rbeta(n, 2, 2) * 8 - 4
  c(x,y)
}

denvelope_for_bivariate <- function(x, c) {
  # x - an instance we need to evaulate
  # c - constant multiplier
  dx <- dbeta((x[1] + 4) / 8, 2, 2)
  dy <- dbeta((x[2] + 4) / 8, 2, 2)
  dx * dy * c
}
```



```{r, echo=FALSE}
library(gridExtra)
scenario1_run_chains <- function() {
  mh_chains_un <- vector(mode = "list", length = 5)
  names(mh_chains_un) <- c('chain_1', 'chain_2', 'chain_3', 'chain_4', 'chain_5')
  for (i in 1:5) {
    mh_chains_un[[paste('chain_', i, sep = '')]] <- metropolis_hastings(dmvnorm, rmvnorm,  c(0, 0), 1000, cov_matrix_prop)
  }
  
  df <- data.frame(mu1 = c(), mu2=c(), samples=c(), chain=c())
  for (i in 1:5) {
    tv1 <- traceplot(mh_chains_un[[paste('chain_', i, sep = '')]][,1])
    tv2 <- traceplot(mh_chains_un[[paste('chain_', i, sep = '')]][,2])
    df <- rbind(df, data.frame(mu1= tv1, mu2=tv2, samples=1:1000, chain=rep(as.character(i), length(tv1))))
  }
  p1 <- ggplot(df) + geom_line(aes(x=samples, y=mu1, color=chain))
  p2 <- ggplot(df) + geom_line(aes(x=samples, y=mu2, color=chain))
  
  
  rej_sampl_chains_un <- vector(mode = "list", length = 5)
  names(rej_sampl_chains_un) <- c('chain_1', 'chain_2', 'chain_3', 'chain_4', 'chain_5')
  for (i in 1:5) {
    rej_sampl_chains_un[[paste('chain_', i, sep = '')]] <- rejection_sampling(1000, dmvnorm, renvelope_for_bivariate, denvelope_for_bivariate, 2.5)
  }
  
  rjdf <- data.frame(mu1 = c(), mu2=c(), samples=c(), chain=c())
  for (i in 1:5) {
    tv1 <- traceplot(rej_sampl_chains_un[[paste('chain_', i, sep = '')]][,1])
    tv2 <- traceplot(rej_sampl_chains_un[[paste('chain_', i, sep = '')]][,2])
    rjdf <- rbind(rjdf, data.frame(mu1= tv1, mu2=tv2, samples=1:1000, chain=rep(as.character(i), length(tv1))))
  }
  
  p3 <- ggplot(rjdf) + geom_line(aes(x=samples, y=mu1, color=chain))
  p4 <- ggplot(rjdf) + geom_line(aes(x=samples, y=mu2, color=chain))
  
  hmc_chains_un <- vector(mode = "list", length = 5)
  names(hmc_chains_un) <- c('chain_1', 'chain_2', 'chain_3', 'chain_4', 'chain_5')
  for (i in 1:5) {
    hmc_chains_un[[paste('chain_', i, sep = '')]] <- hmc_make_samples(minus_log_bivar_st_norm, grad_minus_log_bivar_st_norm, epsilon, L, current_q, 1000)
  }
  
  hmc_df <- data.frame(mu1 = c(), mu2=c(), samples=c(), chain=c())
  for (i in 1:5) {
    tv1 <- traceplot(rej_sampl_chains_un[[paste('chain_', i, sep = '')]][,1])
    tv2 <- traceplot(rej_sampl_chains_un[[paste('chain_', i, sep = '')]][,2])
    hmc_df <- rbind(hmc_df, data.frame(mu1= tv1, mu2=tv2, samples=1:1000, chain=rep(as.character(i), length(tv1))))
  }
  
  p5 <- ggplot(hmc_df) + geom_line(aes(x=samples, y=mu1, color=chain))
  p6 <- ggplot(hmc_df) + geom_line(aes(x=samples, y=mu2, color=chain))
  grid.arrange(p1, p2, p3, p4, p5, p6, ncol=2, nrow=3)
}
scenario1_run_chains()
```
